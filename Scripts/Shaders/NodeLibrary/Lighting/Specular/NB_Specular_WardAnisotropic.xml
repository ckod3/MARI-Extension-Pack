<Node>
    <ID>WardAnisotropic</ID>
    <Inputs>
        <Input Name="SpecularColor" PrettyName="Specular Color" PreferredInput='1'></Input>
        <Input Name="Specular" PrettyName="Specular Weight"></Input>
        <Input Name="SpecularRoughness" PrettyName="Specular Roughness"></Input>
        <Input Name="Anisotropy" PrettyName="Anisotropy"></Input>
        <Input Name="AnisotropicRotation" PrettyName="Anisotropic Rotation"></Input>
        <Input Name="Normal"></Input>
    </Inputs>
    <Attributes>
        <Attribute Name="SpecularRoughness" PrettyName="Specular Roughness" Type="double" Min="0.0" Max="1.0">0.5</Attribute>
        <Attribute Name="Anisotropy" PrettyName="Anisotropy" Type="double" Min="0.1" Max="10.0">1.0</Attribute>
        <Attribute Name="AnisotropicRotation" PrettyName="Anisotropic Rotation" Type="double" Min="0.0" Max="1.0">1.0</Attribute>
    </Attributes>
    <Tags>
        <Tag>_notcacheable</Tag>
        <Tag>_specular</Tag>
    </Tags>
    <Contexts>
    <Context Type="GLSL">
    <Shader ShaderType='Fragment'>
    <Inputs>
        <Input Name="SpecularColor"><Default>vec4(1,1,1,1)</Default></Input>
        <Input Name="Specular"><Default>vec4(1,1,1,1)</Default></Input>
        <Input Name="SpecularRoughness"><Default>vec4(1,1,1,1)</Default></Input>
        <Input Name="Anisotropy"><Default>vec4(1,1,1,1)</Default></Input>
        <Input Name="AnisotropicRotation"><Default>vec4(1,0,0,0)</Default></Input>
        <Input Name="Normal"><Default>vec4(0,0,1,1)</Default></Input>
    </Inputs>
    <Body><![CDATA[

// Ward Anisotropic Specular
// “Measuring and Modelling Anisotropic Reflection” Gregory J. Ward, Computer Graphics 26, 2, July 1992
// Mari 2.5v2 Implementation by Nicholas Breslow (http://nbreslow.com)
// This program is free software: GNU General Public License v3.
// See license distributed with file for more information.

vec3 V = normalize(-State.ViewVectorInEyeSpaceFromViewCamera);    
vec3 N = #Normal.xyz;
vec3 Specular = vec3(0.0);
float SpecularRoughness = clamp(($SpecularRoughness*#SpecularRoughness.r), 0.001,0.999);
float AnisotropicRotation = $AnisotropicRotation*#AnisotropicRotation.r;

for(int i=0;i<4;i++)
{
    // Light Visibility
    float lightVisibility = mriLightVisibility( i, State.Position);

    // Light Direction
    vec3 L = normalize(u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera);
    
    float NdotL = dot(N,L);
    float NdotV = dot(N,V);

    if ( NdotL*NdotV > 0.0 )
    {
        vec2 AnisoRoughness = vec2(SpecularRoughness, (SpecularRoughness / max($Anisotropy,0.001))); // Roughness
        vec3 AnisoDirection = vec3(1.0-AnisotropicRotation,0.0+AnisotropicRotation,0.0); // Tangent Direction
        vec3 X = normalize(cross(N,AnisoDirection)); // Tangent
        vec3 Y = normalize(cross(N,X)); // Bitangent
        vec3 H = normalize(L+V); // Half-Vector
        
        float NdotH = dot(N,H);
        float HdotX = dot(H,X);
        float HdotY = dot(H,Y);

        float FirstTerm = 1.0 / sqrt(NdotL*NdotV);
        float SecondTerm = 1.0/(12.57 * AnisoRoughness.x * AnisoRoughness.y);
        float A = -2.0 * ( pow((HdotX/AnisoRoughness.x),2) + pow((HdotY/AnisoRoughness.y),2) );
        float B = 1.0 + NdotH;
        float ThirdTerm = exp(A/B);
        float ssNdotL = smoothstep(0,0.25,NdotL); // Optional Addition
        float Irradiance = max(0.0,ssNdotL);

        // Ward Anisotropic Specular
        float SpecTerm = FirstTerm * SecondTerm * ThirdTerm * Irradiance;
        Specular += SpecTerm * u_MriLightSources[i].SpecularColor.rgb * lightVisibility;
    }
}

Output.rgb = Specular * #Specular.r * #SpecularColor.rgb;
Output.a = #SpecularColor.a;

    ]]></Body>
    </Shader>
    </Context>
    </Contexts>
</Node>