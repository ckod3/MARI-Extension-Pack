<Node>
    <ID>ReflectionRefraction</ID>
    <Inputs>
        <Input Name="DiffuseColor" PrettyName="Diffuse Color"></Input>
        <Input Name="DiffuseWeight" PrettyName="Diffuse Weight"></Input>
        <Input Name="ReflectionColor" PrettyName="Reflection Color"></Input>
        <Input Name="ReflectionWeight" PrettyName="Reflectivity"></Input>
        <Input Name="RefractionColor" PrettyName="Refraction Color"></Input>
        <Input Name="RefractionWeight" PrettyName="Transparency"></Input>
        <Input Name="IOR" PrettyName="IOR"></Input>
        <Input Name="Normal"></Input>
        <Input Name="AmbientOcclusion" PrettyName="Ambient Occlusion"></Input>
    </Inputs>
    <Attributes>
        <Attribute Name="DiffuseWeight" PrettyName="Diffuse Weight" Type="double" Min="0.0" Max="1.0">1.0</Attribute>
        <Attribute Name="ReflectionWeight" PrettyName="Reflectivity" Type="double" Min="0.0" Max="1.0">1.0</Attribute>
        <Attribute Name="RefractionWeight" PrettyName="Transparency" Type="double" Min="0.0" Max="1.0">0.0</Attribute>
        <Attribute Name="IOR" PrettyName="IOR" Type="double" Min="0.001" Max="25.0">1.4</Attribute>
        <Attribute Name="Ambient" Type="double" Min="0.0" Max="1.0">0.0</Attribute>
        <Attribute Name="AmbientOcclusion" PrettyName="Ambient Occlusion" Type="double" Min="0" Max="2.0">1.0</Attribute>
        <Attribute Name="EnvironmentMap" PrettyName="Environment Map" Group="Environment" Type="image"></Attribute>
    </Attributes>
    <Tags>
        <Tag>_notcacheable</Tag>
        <Tag>_standalone</Tag>
    </Tags>
    <Contexts>
    <Context Type="GLSL">
    <Shader ShaderType='Fragment'>
    <Inputs>
        <Input Name="DiffuseColor"><Default>vec4(0,0,0,0)</Default></Input>
        <Input Name="DiffuseWeight"><Default>vec4(1,1,1,1)</Default></Input>
        <Input Name="ReflectionColor"><Default>vec4(1,1,1,1)</Default></Input>
        <Input Name="ReflectionWeight"><Default>vec4(1,1,1,1)</Default></Input>
        <Input Name="RefractionColor"><Default>vec4(1,1,1,1)</Default></Input>
        <Input Name="RefractionWeight"><Default>vec4(1,1,1,1)</Default></Input>
        <Input Name="IOR"><Default>vec4(1,1,1,1)</Default></Input>
        <Input Name="Normal"><Default>vec4(0,0,1,1)</Default></Input>
        <Input Name="AmbientOcclusion"><Default>vec4(vec3(1.0-State.AmbientOcclusion),1.0)</Default></Input>
    </Inputs>
    <Body><![CDATA[

// Reflection & Refraction with Equirectangular Environment HDR
// Mari 2.5v2 Implementation by Nicholas Breslow (http://nbreslow.com)
// This program is free software: GNU General Public License v3.
// See license distributed with file for more information.

float PI = 3.14159265;
vec3 V = normalize(-State.ViewVectorInEyeSpaceFromViewCamera);
vec3 I = normalize(State.ViewVectorInEyeSpaceFromViewCamera);
vec3 N = normalize(#Normal.xyz);
float IdotN = dot(I,N);
vec3 Nf = (IdotN < 0.0) ? N : -N;
float VdotN = dot(V,N);

vec3 Diffuse = vec3(0.0);
float DiffuseScale = $DiffuseWeight * #DiffuseWeight.r;
float ReflectionScale = $ReflectionWeight * #ReflectionWeight.r;
float RefractionScale = $RefractionWeight * #RefractionWeight.r;
vec3 AO = vec3(1.0 - $AmbientOcclusion * vec3(1.0-#AmbientOcclusion.rgb));

// Fresnel
float IOR = #IOR.r * $IOR;
float Eta = (IdotN < 0.0) ? 1.0/IOR : IOR;
float F0 = (1.0-Eta)/(1.0+Eta);
F0 *= F0;
float Fresnel = F0 + (1.0-F0) * pow(1.0 - VdotN, 5.0);

// Weights
vec3 ReflectionColorScaled = #ReflectionColor.rgb * ReflectionScale * Fresnel;

// Energy Conservation
float DiffuseScaleEC = DiffuseScale
                     * (1.0-min(nb_luminance(#RefractionColor.rgb)*RefractionScale,1.0)) 
                     * (1.0-min(nb_luminance(ReflectionColorScaled),1.0));
float RefractionScaleEC = RefractionScale 
                     * (1.0-min(nb_luminance(ReflectionColorScaled),1.0));

// Weights Cont.
vec3 RefractionColorScaled = #RefractionColor.rgb * RefractionScaleEC * (1.0 - Fresnel);
vec3 DiffuseColorScaled = #DiffuseColor.rgb * DiffuseScaleEC;

// Reflection
vec3 ReflectDir_CamSpace = reflect(I,N);
vec4 ReflectDir_WorldSpace = vec4(ReflectDir_CamSpace, 0.0) * u_MriViewMatrix;
float ReflectYaw = .5 - atan(ReflectDir_WorldSpace.z, -ReflectDir_WorldSpace.x) / (2.0 * PI);
float ReflectPitch = .5 - asin(ReflectDir_WorldSpace.y) / PI;
vec3 ReflectionTrace = texture($EnvironmentMap, vec2(ReflectYaw,ReflectPitch)).rgb;
vec3 Reflection = ReflectionTrace * ReflectionColorScaled;

// Refraction
vec3 RefractDir_CamSpace = refract(I,Nf,Eta);
vec4 RefractDir_WorldSpace = vec4(RefractDir_CamSpace, 0.0) * u_MriViewMatrix;
float RefractYaw = .5 - atan(RefractDir_WorldSpace.z, -RefractDir_WorldSpace.x) / (2.0 * PI);
float RefractPitch = .5 - asin(RefractDir_WorldSpace.y) / PI;
vec3 RefractionTrace = texture($EnvironmentMap, vec2(RefractYaw, RefractPitch)).rgb;
vec3 Refraction = RefractionTrace * RefractionColorScaled;

// Ambient * AO
vec3 Ambient = ($Ambient * DiffuseColorScaled) * AO;

for (int i=0;i<4;i++)
{
    // Light Visibility
    float lightVisibility = mriLightVisibility(i, State.Position);
    
    // Light Direction
    vec3 L = normalize(u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera);

    // Useful Functions
    float NdotL = max(dot(N,L),0.0);

    // Lambert Diffuse
    Diffuse += NdotL * u_MriLightSources[i].DiffuseColor.rgb * lightVisibility;
}

// 0 - Flat  - Diffuse
// 1 - Basic - Diffuse + Ambient
// 2 - Full  - Diffuse + Ambient + Reflection + Refraction

Output.rgb = u_MriLightingMode==0 ? #DiffuseColor.rgb : (Diffuse*DiffuseColorScaled) + Ambient;
Output.rgb += u_MriLightingMode==2 ? Reflection + Refraction : vec3(0.0);
Output.a = #DiffuseColor.a;

    ]]></Body>
    </Shader>
    </Context>
    </Contexts>
</Node>