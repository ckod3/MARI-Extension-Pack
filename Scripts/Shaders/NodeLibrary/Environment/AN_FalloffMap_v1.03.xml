<Node>
    <ID>Falloff Map</ID>
    <Category>Environment/Custom/</Category>
    <Cost>0.01</Cost>
    <CostDescription>Some calculations</CostDescription>
    <Attributes>
        <Attribute Name="FrontColor"	PrettyName="Front Color"			Group="Falloff Parameters" 			Type="color"	Description="Defines the color of the Normals that are facing the camera">(0.0,0.0,0.0,1)</Attribute>
        <Attribute Name="SideColor"		PrettyName="Side Color"				Group="Falloff Parameters" 			Type="color"	Description="Defines the color of the Normals that are look at 90ยบ in relation to the viewing angle">(1.0,1.0,1.0,1)</Attribute>
        <Attribute Name="FalloffType"	PrettyName="Falloff Type/Direction"	Group="Falloff Parameters" 			Type="userenum" Description="Chooses the kind of falloff or direction. This are based on 3DS Max Falloff Map node.">0, 0,1,2,3,4,5,6, Perpendicular/Parallel, Fresnel, Shadow/Light, Distance Blend, Local X Axis, Local Y Axis, Local Z Axis</Attribute>
		<Attribute Name="Falloff" 		PrettyName="Mix Curve"				Group="Mix Curve"					Type="curve"> </Attribute>
		<Attribute Name="IOR"			PrettyName="Index of Refraction"	Group="Mode Specific Parameters"	Type="double"	Description="Sets a new Index of Refraction." Min="0.001" Max="10">1.6</Attribute>
	</Attributes>
    <Tags>
        <Tag>_notcacheable</Tag>
        <Tag>_notbakeable</Tag>
    </Tags>
    <Contexts>
        <Context Type='NodeGraphView'>
        </Context>
            <Context Type='GLSL'>
            <Shader ShaderType='Fragment'>
                <Body>
                <![CDATA[

                vec4 Blend  = vec4 (0.0);
				
				#if defined MRI_SHADER_FRAGMENT || defined MRI_SHADER_TESS_EVALUATION
				
				// Perpendicular/Parallel Mode (Facing Ratio in Maya)
				if ($FalloffType == 0)
				{
					float VdotN = dot(State.ViewVectorInEyeSpaceFromProjectionCamera, State.NormalInEyeSpaceFromProjectionCamera);
					float Fresnel = mriCurveLookup($Falloff, length(VdotN) );
					Blend  = mix($FrontColor, $SideColor, 1-Fresnel);                    
				}

				// Fresnel Mode
				if ($FalloffType == 1)
				{			
					float VdotN = dot(-State.ViewVectorInEyeSpaceFromProjectionCamera, State.NormalInEyeSpaceFromProjectionCamera);
					float IdotN = dot(State.ViewVectorInEyeSpaceFromProjectionCamera, State.NormalInEyeSpaceFromProjectionCamera);
					float Eta = (IdotN < 0.0) ? 1.0/$IOR : $IOR;
					float F0 = (1.0-Eta)/(1.0+Eta);
					F0 *= F0;
					float Fresnel = F0 + (1.0-F0) * pow(1.0 - VdotN, 5.0);
					Fresnel = mriCurveLookup($Falloff, length(Fresnel) );
					Blend  = mix($FrontColor, $SideColor, Fresnel);   
				}
					
				// Shadow/Light Mode
				if ($FalloffType == 2)
				{											
					for(int i=0;i<4;i++)
					{
						if( vec3( 0) == u_MriLightSources[i].DiffuseColor.rgb && vec3( 0) == u_MriLightSources[i].SpecularColor.rgb)
						{
							continue;
						}
						
						vec3 L = normalize(u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromProjectionCamera);
						float lightVisibility = mriLightVisibility( i, State.Position);                        
						
						float NdotL = max(0, dot(State.NormalInEyeSpaceFromProjectionCamera, L) );
						float Fresnel = mriCurveLookup($Falloff, length(NdotL) );
						Blend += mix($FrontColor, $SideColor, Fresnel) * NdotL * lightVisibility;						
					}    				
				}

				// Distance Blend Mode
				if ($FalloffType == 3)
				{
					float Fresnel = mriCurveLookup($Falloff, length(gl_FragDepth) );
					Blend = mix($FrontColor, $SideColor, 1-Fresnel );
				}			
								
				// Local X Axis
				if ($FalloffType == 4)
                {
					vec3 N = vec3(0,0,State.Position.z);
					vec3 P = N*u_MriObjectRadius+u_MriObjectCenter;
					float d = -dot(N,P);
					float D = abs(dot(N,State.Position)+d)/length(P);
					D /=u_MriObjectRadius;					
                    float Fresnel = mriCurveLookup($Falloff, length(D) );
                    Blend  = mix($FrontColor, $SideColor, Fresnel);                    
                }
				
				// Local Y Axis
				if ($FalloffType == 5)
                {
					vec3 N = vec3(0,State.Position.y,0);
					vec3 P = N*u_MriObjectRadius+u_MriObjectCenter;
					float d = -dot(N,P);
					float D = abs(dot(N,State.Position)+d)/length(P);
					D /=u_MriObjectRadius;					
                    float Fresnel = mriCurveLookup($Falloff, length(D) );
                    Blend  = mix($FrontColor, $SideColor, Fresnel);                    
                }
				
				// Local Z Axis
				if ($FalloffType == 6)
                {
					vec3 N = vec3(State.Position.x,0,0);
					vec3 P = N*u_MriObjectRadius+u_MriObjectCenter;
					float d = -dot(N,P);
					float D = abs(dot(N,State.Position)+d)/length(P);
					D /=u_MriObjectRadius;					
                    float Fresnel = mriCurveLookup($Falloff, length(D) );
                    Blend  = mix($FrontColor, $SideColor, Fresnel);                    
                }				
				#endif	
				
                Output.rgb = Blend.rgb;
				Output.a = 1.0;
                ]]>
                </Body>
            </Shader>
        </Context>
    </Contexts>
</Node>
