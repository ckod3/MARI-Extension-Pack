<Node>
  <ID> Cylindrical Projection</ID>
  <Category>Environment/Custom/</Category>
  <DefaultName>Cylindrical Projection</DefaultName>
  <Cost>0.01</Cost>
  <CostDescription>Some calculations</CostDescription>
  <Description>Project Image as Cylindrical Projection</Description>
  <Inputs>
        <Input Name="Input"/>
  </Inputs>
  <Attributes>
   <!--===============================================================================================================-->
  <Attribute Name="Debug"    PrettyName="Debug Pattern"           Group="Texture Map"   Type="bool"                      >false</Attribute>
  <Attribute Name="Map"           PrettyName="Texture Map"       Group="Texture Map"  Type="image" GenerateMipMaps="false"   ></Attribute>  
  <Attribute Name="ImageRot"      PrettyName="Image Rotation"    Group="Texture Map"  Type="double" Min="0"     Max="360"    >0</Attribute>
  <Attribute Name="Spin"          PrettyName="Slide UVs"       Group="Texture Map"  Type="double" Min="0"     Max="360"    >0</Attribute>
  <!--===============================================================================================================-->
  <Attribute Name="Length"        PrettyName="Length"           Group="Cylinder Dimension"   Type="double" Min="0"     Max="1000"    >50</Attribute>
  <Attribute Name="R"             PrettyName="Radius"           Group="Cylinder Dimension"   Type="double" Min="0.00001"     Max="1000"    >1000</Attribute>
  <!--===============================================================================================================-->
  <Attribute Name="RepX"          PrettyName="RepeatU"          Group="UV Size"     Type="double" Min="0"     Max="100"    >1</Attribute>
  <Attribute Name="RepY"          PrettyName="RepeatV"          Group="UV Size"     Type="double" Min="0"     Max="100"    >20</Attribute>
  <Attribute Name="WorldScale"    PrettyName="UV Scale"       Group="UV Size"     Type="double" Min="0"     Max="100"    >5</Attribute>
  <!--===============================================================================================================-->
   <Attribute Name="XOffset"       PrettyName="X Offset"         Group="Offset Pivot (World)"   Type="double"  Min="-10000"     Max="10000"    >0</Attribute>
  <Attribute Name="XFine"         PrettyName="Offset"           Group="Offset Pivot (World)"   Type="double" Min="-10"     Max="10"       >0</Attribute>
  <Attribute Name="YOffset"       PrettyName="Y Offset"         Group="Offset Pivot (World)"   Type="double" Min="-10000"     Max="10000" >0</Attribute>
  <Attribute Name="YFine"         PrettyName="Offset"           Group="Offset Pivot (World)"   Type="double" Min="-10"     Max="10"        >0</Attribute>
  <Attribute Name="ZOffset"       PrettyName="Z Offset"         Group="Offset Pivot (World)"   Type="double"  Min="-10000"     Max="10000"  >0</Attribute>
  <Attribute Name="ZFine"         PrettyName="Offset"           Group="Offset Pivot (World)"   Type="double" Min="-10"     Max="10"        >0</Attribute>
  <!--===============================================================================================================-->
  <Attribute Name="rX"            PrettyName="Rotate X"         Group="Transform Rotate (World)"   Type="double" Min="0"     Max="360"                       >90</Attribute>
  <Attribute Name="rY"            PrettyName="Rotate Y"         Group="Transform Rotate (World)"   Type="double" Min="0"     Max="360"                       >0</Attribute>
  <Attribute Name="rZ"            PrettyName="Rotate Z"         Group="Transform Rotate (World)"   Type="double" Min="0"     Max="360"                       >0</Attribute>
  <!--===============================================================================================================-->
  <Attribute Name="rlX"            PrettyName="Rotate X"         Group="Transform Rotate (Local)"   Type="double" Min="0"     Max="360"                       >0</Attribute>
  <Attribute Name="rlY"            PrettyName="Rotate Y"         Group="Transform Rotate (Local)"   Type="double" Min="0"     Max="360"                       >0</Attribute>
  <Attribute Name="rlZ"            PrettyName="Rotate Z"         Group="Transform Rotate (Local)"   Type="double" Min="0"     Max="360"                       >0</Attribute>
  <!--===============================================================================================================-->
  <Attribute Name="ClipC"         PrettyName="Plane Slice Start" Group="Pie Clip"            Type="double" Min="0"      Max="1"     >0.0</Attribute>
  <Attribute Name="ClipCFine"     PrettyName="Offset"           Group="Pie Clip"            Type="double" Min="-1"      Max="1"     >0.0</Attribute>
  <Attribute Name="ClipD"         PrettyName="Plane Slice End"  Group="Pie Clip"            Type="double" Min="0"      Max="1"     >1.0</Attribute>
  <Attribute Name="ClipDFine"     PrettyName="Offset"           Group="Pie Clip"            Type="double" Min="-1"      Max="1"     >0.0</Attribute>
  <Attribute Name="ClipA"         PrettyName="Pie Slice Start"      Group="Pie Clip"            Type="double" Min="0"      Max="360"     >0</Attribute>
  <Attribute Name="ClipAFine"     PrettyName="Offset"           Group="Pie Clip"            Type="double" Min="-5"      Max="5"     >0.0</Attribute>
  <Attribute Name="ClipB"         PrettyName="Pie Slice End"        Group="Pie Clip"            Type="double" Min="0"      Max="360"     >360</Attribute>
  <Attribute Name="ClipBFine"     PrettyName="Offset"           Group="Pie Clip"            Type="double" Min="-5"      Max="5"     >0.0</Attribute>
  <!--===============================================================================================================-->
  <Attribute Name="PreviewPos"    PrettyName="Display Object Position as Color Value"           Group="Transform Helpers"   Type="bool"                      >false</Attribute>
  <Attribute Name="InvertZ"    PrettyName="Reverse Base Orientation"           Group="Transform Helpers"   Type="bool"                      >false</Attribute>
  <Attribute Name="OffsetMult"    PrettyName="Transform / Clip Offset Multiplier"                 Group="Transform Helpers"            Type="double" Min="0.001"      Max="100"     >1.0</Attribute>
  <!--===============================================================================================================-->  

  </Attributes>
    <Contexts>
      <Context Type="NodeGraphView">
          <Inputs>
              <Input Name="Mask"><Pos>100,0</Pos></Input>
              <Input Name="Position"><Pos>100,-20</Pos></Input>
              <Input Name="Normal"><Pos>100,+20</Pos></Input>
          </Inputs>
      </Context>
      <Context Type="GLSL">
            <Shader ShaderType='Fragment'>
                <Inputs>
                    <Input Name="Input"> <Default>vec4(1.0)</Default> </Input>
                </Inputs>
            </Shader>
            <Shader ShaderType='TessEvaluation'>
                <Inputs>
                    <Input Name="Input"> <Default>vec4(1.0)</Default> </Input>
                </Inputs>
            </Shader>
            <Shader>


              <Body>
    <![CDATA[


// TO DO:
// Rotation is still broken somehow. No clue.



const float PI=3.1415926538979 ;


//-----------------------------------------------------------
// Transformation Projection Cylinder
//-----------------------------------------------------------

float XOffset = $XOffset + ($XFine*$OffsetMult);
float YOffset = $YOffset + ($YFine*$OffsetMult);
float ZOffset = $ZOffset + ($ZFine*$OffsetMult) ;
vec3 trans = vec3(XOffset,YOffset,ZOffset);
vec3 transl = vec3(XOffset,YOffset,0.0);
vec3 rot = (vec3($rX,$rY,$rZ));
vec3 rotl = (vec3($rlX,$rlY,$rlZ));
vec3 fixed_scale = vec3(1.0);


// _P is the original mix between user set values and if checkbox marked, Object Centre
vec3 _P = State.Position;

// _PzP is used to set the centre point for the length of the cylinder. Length scale pivot is set to base value set in translation
vec3 _PzP = vec3(_P.x,_P.y,_P.z);


//..........................................................................................
// Trying different things for the rotation pivot
//..........................................................................................

// DON't ADD ANY VALUES HERE OR THERE CENTER WILL CHANGE
vec3 _oPP = positionTransform(_P,trans,rot,fixed_scale);
vec3 _PP = translate(_oPP,-transl);
    
    // float radian = PI/180.0;
    // float angleA = $rX / 360 ;
    // float angleB = $rY / 360 ;
    // float angleC = $rZ / 360;

    // mat3 rotx = rotation($rlX,vec3(angleA,angleB,angleC));
    // mat3 roty = rotation($rlY,vec3(angleA,angleB,angleC));
    // mat3 rotz = rotation($rlZ,vec3(angleA,angleB,angleC));

    // _PP = _PP * (rotx * roty * rotz);
// _PP = positionTransform(_PP,vec3(0.0),-rot,vec3(1.0));
_PP = positionTransform(_PP,vec3(1.0),rotl,vec3(1.0));
// _PP = positionTransform(_PP,vec3(0.0),rot,vec3(1.0));
_PP = translate(_PP,transl);



//..........................................................................................


// Generating Original Position with just rotation as well. 
// This is necessary to evaluate Radius and Length correctly when Cylinder is rotated


vec3 _PPOrig = _PP;



//-----------------------------------------------------------
// Image Rotation Matrix & Sin
//-----------------------------------------------------------

float angleRads = radians( $ImageRot);
float cosAngle = cos( angleRads);
float sinAngle = sin( angleRads);
mat2 ImageRot = mat2( cosAngle, -sinAngle, sinAngle, cosAngle );

float spin = $Spin/360;

//-----------------------------------------------------------
// Main Cylindrical Projection Coordinates
//-----------------------------------------------------------



float ss = 1-(atan(_PP.x,_PP.y) + PI ) / (2.0*PI);
float tt = (1-_PP.z)/float($Length);
vec2 _uv = vec2(ss,tt);
vec2 _uvP = vec2(ss,(1.0-_PP.z));
vec2 rep = vec2($RepX,$RepY)/vec2($WorldScale);

vec2 _uvC = ((_uv+spin)*rep*$R);



//-----------------------------------------------------------
// Alpha Clipping - Pie Style and Radius Projection Clipping
//-----------------------------------------------------------

vec2 _uvA1 = ((_uvP +spin) )/4.0;

// Slice Clip in Angle of Cylinder

float Angle = 0.0 ;
vec2 N_1 = -vec2(cos(Angle),sin(Angle));
N_1 = normalize(N_1);
vec2 P_1 = N_1*0.5+vec2(0.5);
float d_1 = -dot(N_1,P_1)+vec2(0.5);
float D_1 = (dot(N_1,_uvA1)+d_1)/length(P_1);
D_1 /=0.5;
D_1 = fract(1.0-D_1);


// Clip Values for Slice and Plane Slice Clip

float ClipA = $ClipA/360 + $ClipAFine/360;
float ClipB = $ClipB/360 + $ClipBFine/360;
float ClipC = $ClipC + ( ($ClipCFine*$OffsetMult) /10);
float ClipD = $ClipD + ( ($ClipDFine*$OffsetMult) /10);

// Hard edged clip. Lots of decimals

float D1 = (D_1-ClipA)/((ClipA+0.0000000000000000000000000000000001)-ClipA);
float D2 = 1-((D_1-ClipB)/((ClipB+0.0000000000000000000000000000000001)-ClipB));

// creating black and white clip mask from Pie Clip

float mixval_1 = mix(vec4(0.0),vec4(1.0),clamp(D1,0.0,1.0));
float mixval_2 = mix(vec4(0.0),vec4(1.0),clamp(D2,0.0,1.0));

// Creating Alpha Result from PieSliceMask, Slice Pie clipping is created via Projection Limits

float AlphaResult = mixval_1*mixval_2 ;


// Generating Projection Bound Limits from Length and Radius

vec3 boundingBox;
boundingBox.x = ( (_PPOrig.x > (XOffset + $R )) || (_PPOrig.x < (XOffset - $R)) ) ? 0.0 : 1.0; 
boundingBox.y = ( (_PPOrig.y > (YOffset + $R)) || (_PPOrig.y < (YOffset - $R)) ) ? 0.0 : 1.0; 

float offset = mix(($ZOffset-$Length),($ZOffset+$Length),float($InvertZ));

// Using "Length" method for evaluating Slice Clip. Comparing Value of Z + ZOffset + Length to get proper Z Size of Cylinder
boundingBox.z = ( (_PP.z + offset + (ClipC*$Length*2) > (ZOffset + ($Length) )) || (_PP.z + offset - ((1.0-ClipD)*$Length*2)< (ZOffset - ($Length) )) ) ? 0.0 : 1.0; 


float boxAlpha = clamp((boundingBox.x*boundingBox.y*boundingBox.z),0.0,1.0);



//-----------------------------------------------------------
// Result combining
//-----------------------------------------------------------


// vec4 result;
vec4 prevPos = vec4(State.Position,1.0);
_uvC = (_uvC*ImageRot)+vec2(0.0,trans.z);
vec4 ColorResult = texture2D( $Map,_uvC) ;
ColorResult = ($Debug) ? vec4(vec3(nb_superEllipse2D(_uvC/vec2(1,1), 0.9, 50)),1.0) : ColorResult;
ColorResult.a =   (AlphaResult*ColorResult.a) * boxAlpha ; 
Output = mix(ColorResult,prevPos,float($PreviewPos));




        ]]>
              </Body>
          </Shader>
      </Context>
  </Contexts>
</Node>