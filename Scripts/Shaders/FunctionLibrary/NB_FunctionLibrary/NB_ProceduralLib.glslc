#version 150
#extension GL_ARB_gpu_shader5 : enable

//! include | Surface.glslh

MriFragmentState State;
MriSystemFragmentState _State;

// Mari 2.5v2 Implementation by Nicholas Breslow (http://nbreslow.com)
// This program is free software: GNU General Public License v3.
// See license distributed with file for more information.

// Compute the square of a given value.
float nb_sq(float x)
{
    return x * x;
}

//This function will evaluate the result of function F with some UV shift. f0 is the initial value of F at the original UV. dUV is the UV shift.
float nbF(float f0, vec2 dUV)
{
    return f0 + dFdu(f0)*dUV.s + dFdv(f0)*dUV.t;
}

//This function will evaluate the result of function F with some UV shift. f0 is the initial value of F at the original UV. dUV is the UV shift.
vec2 nbF(vec2 f0, vec2 dUV)
{
    return f0 + dFdu(f0)*dUV.s + dFdv(f0)*dUV.t;
}

//This function will evaluate the result of function F with some UV shift. f0 is the initial value of F at the original UV. dUV is the UV shift.
vec3 nbF(vec3 f0, vec2 dUV)
{
    return f0 + dFdu(f0)*dUV.s + dFdv(f0)*dUV.t;
}

// Anti-aliased step for procedurals where 'threshold' is constant and 'value' is smoothly varying
float nb_AAstep(float threshold, float value)
{
	float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));
	return smoothstep(threshold-afwidth, threshold+afwidth, value);
}

// http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
// Produces approximately uniformly distributed values in the interval [0,1].

// Random hash generator
float nb_randomHash(float input)
{
    return fract(sin(input)*43758.5453);
}

float nb_randomHash(vec2 input)
{
    return fract(sin(dot(input.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

// Random float generator [0,1]
float nb_randomFloat(vec2 input)
{
	uint n = floatBitsToUint(input.y * 214013.0 + input.x * 2531011.0);
	n = n * (n * n * 15731u + 789221u);
	n = (n >> 9u) | 0x3F800000u;
	return 2.0 - uintBitsToFloat(n);
}

// Distance^2
float nb_distanceSquared(float x, float y, float z)
{
	return (x * x + y * y + z * z);
}

// Distance Real
float nb_distanceReal(float x, float y, float z)
{
	return sqrt(x * x + y * y + z * z);
}

// Distance Quadratic
float nb_distanceQuadratic(float x, float y, float z)
{
	return (x * x + y * y + z * z + x * y + x * z + y * z);
}


// Rotation matrix around an arbitrary axis
mat3 nb_rotationMatrix3(vec3 inAxis, float angle)
{
    vec3 axis = normalize(inAxis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    return mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,
                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,
                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);
}

// Rotation matrix around an arbitrary axis
mat4 nb_rotationMatrix4(vec3 inAxis, float angle)
{
	vec3 axis = normalize(inAxis);
	float s = sin(angle);
	float c = cos(angle);
	float oc = 1.0 - c;
	return mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,
	            oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,
	            oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,
	            0.0, 0.0, 0.0, 1.0);
}

// Almost Identity
// Avoid small values screwing up computations by blending your value with your threshold.
// m = threshold where anything above stays unchanged
// n =  the value things will take when your value is zero
// Source: http://iquilezles.org/www/articles/functions/functions.htm

float nb_almostIdentity(float x, float m, float n)
{
    if( x>m ) return x;

    float a = 2.0 * n - m;
    float b = 2.0 * m - 3.0 * n;
    float t = x/m;

    return (a*t + b) * t * t + n;
}

// Impulse
// For anything that grows fast and then slowly decays.
// k = stretch control
// Note: It's maximun, which is 1.0, happens at exactly x = 1/k.
// Source: http://iquilezles.org/www/articles/functions/functions.htm

float nb_impulse(float k, float x)
{
    float h = k * x;
    return h * exp(1.0 - h);
}

// Cubic Pulse
// Use instead of smoothstep to isolate features.
// Source: http://iquilezles.org/www/articles/functions/functions.htm

float nb_cubicPulse(float c, float w, float x)
{
    x = abs(x - c);
    if( x>w ) return 0.0;
    x /= w;
    return 1.0 - x * x * (3.0 - 2.0 * x);
}

// Exponential Step
// A natural attenuation is an exponential of a linearly decaying quantity
// Source: http://iquilezles.org/www/articles/functions/functions.htm

float nb_expStep(float x, float k, float n)
{
    return exp( -k * pow(x,n) );
}

// Parabola
// Remap the 0..1 interval such that the corners are remaped to 0 and the center to 1
// Source: http://iquilezles.org/www/articles/functions/functions.htm

float nb_parabola(float x, float k)
{
    return pow( 4.0 * x * (1.0-x), k );
}

// Compute the CIE luminance (Rec. 709) of a given color
float nb_luminance(vec3 colorIn)
{
    return colorIn.r * 0.212671 + colorIn.g * 0.715160 + colorIn.b * 0.072169;
}