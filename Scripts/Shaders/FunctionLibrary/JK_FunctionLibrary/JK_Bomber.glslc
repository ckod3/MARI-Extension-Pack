// TO DO:
//
// BUG: radialFader is only called once but without the Mapprescaling, need to duplicate it!
//
// -- New Noise Controls broke Density + DensityGain. Seems to be the old problem with the value seeding
// -- -> Check against previous commits if something else has changed with the Density
// -- Some of the Noise_Scale Attributes aren't used
// -- clean up unused functions in header
// -- clean up unsed variables
// -- do proper includes in glsh
// -- investigate excluding Value from HSV Mix
// -- investigate excluding/Mixing RndScale (probably not, is overkill but if it's easy enough)


// -- STUFF FOR SEPARATE 3D NODE --
// - add 3d projection of cells
//
//   AS ADJUSTMENT LAYER/USING INCOMING DATA: 
// - add painted distribution of cells. Sampling from incoming texture layers, then only using
//   transparency from bomber
// - potentially add distribution per texture via RGB Values of incoming vec4 data
// - potentially add switch to paint frequency/denisity per texture via RGB (similar to above)


// ------------------------------------------------------------------------
// OPENGL VERSION
// ------------------------------------------------------------------------

#version 330

// ------------------------------------------------------------------------
// INCLUDES
// ------------------------------------------------------------------------

// DO I NEED NOISE.GLSLH ?

//! include | Noise.glslh
//! include | Comp.glslh

// ------------------------------------------------------------------------
// Forward declaration from other files
// ------------------------------------------------------------------------


// TO DO: CLEAN UP UNUSED !

float Value3D( vec3 P );
void voronoi(vec3 position, float jitterD, int distype, out float f1, out float f2, out vec3 pos1,
         out vec3 pos2, out vec3 f1cell, out vec3 f2cell);
vec4 CellNoise( vec3 gridcell );
float SimplexPerlin3D(vec3 P);
float rmfBm (vec3 P, float octaves, float lacunarity, float gain, float amp, float freqOffset);


// for use in voronoi_simple
float rnd_1d(vec2 x);
float dist_Squared(float x, float y, float z);
float softThreshold(float threshold, float bound, float value);

// for radial fade
float remap(float value, float oldMin, float oldMax, float newMin, float newMax, float multiplier);

float boxStep(float low, float high, float value);

// ------------------------------------------------------------------------
// MACROS
// ------------------------------------------------------------------------

#define whichtile(x,freq) (floor((x) * (freq)))



// ------------------------------------------------------------------------
// FUNCTIONS
// ------------------------------------------------------------------------


// voronoi cellular pattern generator from DT3D_CellularNoise.glslc 
// but a little simplified for better performance and with a threshold.
void voronoi_simple(vec3 position, float jitterD,out vec3 f1cell,float threshold,float threshold_bound)
{
    vec3 thiscell = floor(position)+0.5f;
    float i, j, k, dist;

    vec3 c;
    for(i = -1; i <= 1; i += 1)
    {
        for(j = -1; j <= 1; j += 1)
        {
            for(k = -1; k <= 1; k += 1)
            {
                vec3 testcell = thiscell  + vec3(i,j,k);
                vec3 randomUVW = testcell * vec3(0.037f, 0.119f, .093f);
                float cellnoise = (rnd_1d(randomUVW.xy+randomUVW.z+0.2),rnd_1d(randomUVW.xy+randomUVW.z+0.5),rnd_1d(randomUVW.xy+randomUVW.z+0.3));
                vec3 pos = testcell + jitterD*(cellnoise-0.5);
                vec3 offset = pos - position;
                dist = dist_Squared(offset.x,offset.y,offset.z);
   
                f1cell = vec3( softThreshold(threshold,threshold_bound,cellnoise) );      

            
            }
        }
    }
}



// CRAPPY, currently used once.
float udn(float x,float scale,float lo,float hi)
{ 
  vec3 x_3 = vec3(x*scale);
  float valnoi = Value3D(x_3);
  float output = (smoothstep(.25, .75, (valnoi)) * ((hi) - (lo)) + (lo));
  return output;
}


// A very expensive, voronoi based noise for seeding. Currently in use
// for rotation and jitter. Potentially switch jitter to a less expensive one !
float udnVor(float x,float scale,float lo,float hi, float threshold, float threshold_bound)
{ 
  vec3 x_3 = vec3(x*scale);
  float outf1,outf2;
  vec3 pos1,pos2,f1cell,f2cell;
  voronoi_simple(x_3,1.0,f1cell,threshold,threshold_bound);
  float remap = f1cell.r;
  float output = (smoothstep(.25, .75, (remap)) * ((hi) - (lo)) + (lo));
  return output;
}

// A very expensive, voronoi based noise for seeding. Currently in use
// for rotation and jitter. Potentially switch jitter to a less expensive one !
float udnVor2(float x,float scale)
{ 
  vec3 x_3 = vec3(x+scale*scale);
  float remap = cellular(x_3, 3)[2];
  float output = remap;
  return output;
}


float steppedFBM(float x,float scale,float lo,float hi, float threshold, float threshold_bound)
{ 
  vec3 x_3 = vec3(x*scale);
  float remap = rmfBm(x_3,5.0,1.0,1.0,1.0,0.5);
  remap = softThreshold(threshold,threshold_bound,remap);
  float output = (smoothstep(0.25, 0.75, (remap)) * ((hi) - (lo)) + (lo));
  // float output = (remap * ((hi) - (lo)) + (lo));
  return output;
}





// ------------------------------------------------------------------------------------------------------
// ---------------------------MAIN TEXTURE SCATTER------------------------------------------------------
// ------------------------------------------------------------------------------------------------------                      
                       



vec4 JK_texScatter( 

                    vec2 UV,
                    vec3 POS,
                    float scale,
                    float ScaleRnd,
                    float ScaleRndWeight,
                    float frequency,
                    float layers,
                    float forceTile,
                    float noise_scale_A,
                    float noise_scale_B,
                    float noise_scale_C,
                    float noise_scale_D,
                    float jitter_scale,
                    float rot_min,
                    float rot_max,
                    int textureCount,
                    int BlendMode,
                    float MapASize,
                    float MapBSize,
                    float MapCSize,
                    float MapDSize,
                    float HSVSeed,
                    float ValueOffset,
                    float LayerAttenuation,
                    float A_minH,
                    float A_maxH,
                    float A_minS,
                    float A_maxS,
                    float A_minV,
                    float A_maxV,
                    float HSVMixA,
                    float HSVMixB,
                    float HSVMixC,
                    float HSVMixD,
                    float clampValues,
                    sampler2D textureA,
                    float invert_textureA,
                    float radialFadeA,
                    float radialFade_SoftnessA,
                    int textureA_AlphaMode,
                    sampler2D textureB,
                    float textureB_weight,
                    float invert_textureB,
                    float radialFadeB,
                    float radialFade_SoftnessB,
                    int textureB_AlphaMode,
                    sampler2D textureC,
                    float textureC_weight,
                    float invert_textureC,
                    float radialFadeC,
                    float radialFade_SoftnessC,
                    int textureC_AlphaMode,
                    sampler2D textureD,
                    float textureD_weight,
                    float invert_textureD,
                    float radialFadeD,
                    float radialFade_SoftnessD,
                    int textureD_AlphaMode
				            )



{

// ------------------------------------------------------------------------------------------------------
//                      Unassigned Variables
// ------------------------------------------------------------------------------------------------------                      
                       

  vec4 layer_color,layer_color_B,layer_color_C,layer_color_D;
  vec4 surface_color;
  vec4 layer_color_comb,layer_color_comb_B,layer_color_comb_C;
  vec4 layer_opac,surface_opac;
  float layer_alpha;
  float ss, tt,tmps,tmpt;
  float home_row,home_col;
  float layer_idx,col_idx,row_idx;
  float cell_size;
  float half_cell;
  float col, row;
  float noi,noi_minor,noi_major,noi_scalrRnd;
  float rel_s, rel_t;
  float jitter_s, jitter_t;
  float center_s, center_t;
  float sMin, sMax, tMin, tMax;
  float inBounds;
  float max_jitter;
  float offset;
  vec2 d;
  float MixVal;
  float _tmpmix;



// DELETE:
  float _floatPreview;
  vec3 _vec3Preview;





// ------------------------------------------------------------------------------------------------------
//                      Assigned Variables
// ------------------------------------------------------------------------------------------------------                      
  int tmpscale = int(scale);
  scale = mix(scale,float(tmpscale),forceTile); 

  float s = UV.x;
  float t = UV.y;
  cell_size = (1.0 / (scale)) ;
  half_cell = cell_size / 2.0;
  surface_color = vec4(0.0,0.0,0.0,0.0);
  surface_opac = vec4(0.0,0.0,0.0,1.0);
  float texCount = float(textureCount);
  home_col = whichtile(s,scale);
  home_row = whichtile(t,scale);

  // The following are used to generate a mix map for the HSV Shift based on HSV Mix Sliders
  float HSSVFinalMix = HSVMixA;

// ------------------------------------------------------------------------------------------------------
//                      ROW/COL/LAYER INDEXING
// ------------------------------------------------------------------------------------------------------                      
        


  // small offset on layer idx to compensate for precision
  for (layer_idx = 0.999; layer_idx < layers; layer_idx += 1.0)

    {
      noise_scale_A = noise_scale_A + (10.0 * layer_idx);
      jitter_scale = jitter_scale + (layer_idx/5.0);



      // scan current cell and neighbors, 9 cells total
      for (col_idx = -1.0; col_idx <= 1.0; col_idx += 1.0)
       	{
       		for (row_idx = -1.0; row_idx <= 1.0; row_idx += 1.0)
       			{

       				// determine row and column index, wraparound
       				rel_s = s;
       				rel_t = t;
					
					    col = home_col + col_idx;
       				
       				if (col < 0.0) 
       					{
       						rel_s = s + 1.0;
       						col = scale - 1.0;
       					}
       					
       				if (col >= scale) 
       					{
       						rel_s = s - 1.0;
       						col = 0.0;
       					}
       				
       				row = home_row + row_idx;

       				if (row < 0.0) 
       					{
       						rel_t = t + 1.0;
       						row = scale - 1.0;
       					}

       				if (row >= scale) 

       					{
       						rel_t = t - 1.0;
       						row = 0.0;
       					}

 
// ------------------------------------------------------------------------------------------------------
//                     Seeding Value. Used all over the place for rotation, jitter,texture mix etc.
//                     Improving this to be less repetitve would go a long way
// ------------------------------------------------------------------------------------------------------                      
              noi_major = (Value3D ( vec3(col * noise_scale_A + 123.0, 
                        row * noise_scale_A - 345.0,
                        layer_idx * noise_scale_A + 222.0)
                              )
                  ) ;
           

              noi_minor = (SimplexPerlin3D ( vec3(col * noise_scale_B + 0.5, 
                        row * noise_scale_B * layer_idx + 0.5,
                        layer_idx * noise_scale_B + 222.0)
                              ) * noise_scale_A
                  ) ;

              noi = (Value3D ( vec3(col * noise_scale_A + 123.0, 
                        row * noise_scale_A - 345.0,
                        layer_idx * noise_scale_A + 222.0)
                              ) + noi_minor
                  ) ;

        
              noi_scalrRnd = (udnVor( (noi * 12358) * layer_idx,noise_scale_D*layer_idx, 0.0, ScaleRndWeight+0.3,0.01,8.0));

// ------------------------------------------------------------------------------------------------------
//                      Jitter
// ------------------------------------------------------------------------------------------------------                      
                       

       				if ((noi_major * noi_minor) < frequency*10.0)
       			    {			
       	          max_jitter = cell_size*0.5;

                  jitter_s = udnVor(noi_major * (1183.127*layer_idx),(jitter_scale+layer_idx)*layer_idx, -max_jitter, max_jitter,0.5,1.0);
                  jitter_t = udnVor(noi_major * (9999.123*layer_idx),(jitter_scale+layer_idx)*(layer_idx+1.0), -max_jitter, max_jitter,0.5,1.0) ;
                 
// ------------------------------------------------------------------------------------------------------
//                      Cell Centre and Scale Randomization
// ------------------------------------------------------------------------------------------------------                      
                     

                  // Scale Randomizer
                  float noi_f = smoothstep(noi_scalrRnd,1.0,(ScaleRnd));

                  //center of texture on surface
                  center_s = ((col * cell_size) + half_cell + jitter_s);
                  center_t = ((row * cell_size) + half_cell + jitter_t);

// ------------------------------------------------------------------------------------------------------
//                      Rotation of each cell
// ------------------------------------------------------------------------------------------------------                      
                       
     					    float x = udn(rel_s,1.0,rel_s,0.0);
     					    float y = udn(rel_t,1.0,rel_t,0.0);
     					    float rad = radians(udnVor( (noi_minor * 777) * layer_idx,noise_scale_A*layer_idx, rot_min, rot_max,0.5,8.0));
                  rad = remap(rad,0.0,1.0,-1.0,1.0,1.0);
     					    float ox = (col * cell_size) + half_cell;
                  float oy = (row * cell_size) + half_cell;
     					    tmps = ((x) - (ox)) * cos(rad) - ((y) - (oy)) * sin(rad) + (ox);
     					    tmpt = ((x) - (ox)) * sin(rad) + ((y) - (oy)) * cos(rad) + (oy);


// ------------------------------------------------------------------------------------------------------
//                      Per Cell Texture Coordinates
// ------------------------------------------------------------------------------------------------------                      
                  

       					  //bounds for texture in this layer
       					  sMin = (center_s - half_cell) ;
       					  sMax = (center_s + half_cell) ;
       					  tMin = (center_t - half_cell) ;
       					  tMax = (center_t + half_cell) ;
       					     
       					  // check if the current point on the surface is in the texture area
       					  inBounds = 1.0;
       					  if (tmps <= sMin) inBounds = 0;
       					  if (tmps >= sMax) inBounds = 0;
       					  if (tmpt <= tMin) inBounds = 0;
       					  if (tmpt >= tMax) inBounds = 0;
       			      
       						if (inBounds == 1.0)
                    {
                    

                      // calculate texture coordinates
                      ss = ( (tmps - sMax)) ;
                      tt = ( (tmpt - tMax)) ;

                      float ss_c = ( (center_s));
                      float tt_c = ( (center_t));

                      // UVs for each cell
                      vec2 n_uv = vec2(ss,tt) * (scale/noi_f) ;

                      


// ------------------------------------------------------------------------------------------------------
//                      Start of Texture A,B,C,D
// ------------------------------------------------------------------------------------------------------                      
                          


                      // get color from texture maps and weigh them per importance
                      // importance is determined via thresholding function on a FBM Noise
                      // Depending on Mode set, Alphas are evaluated differently via Switches
                      // However Alphas are always multiplied by the radial fade in the end

                      layer_color = texture(textureA,n_uv*MapASize);
                      layer_color.rgb = mix(layer_color.rgb,vec3(1.0)-layer_color.rgb,invert_textureA);

                      // for use in all radial Fades for all textures
                      float radialFade = length((n_uv)+vec2(0.5));
                  
                      // Determine what Alpha is being used. 1) From loaded image 2) Luminance 3)Inv Luminance
                      // Please note the texture invert is being evaluated before !
                      switch (textureA_AlphaMode)
                        {
                          case 0:
                          //From Map
                          break;
                          case 1:
                          //Alpha is Luminance
                          layer_color.a = dot(vec3(0.2126, 0.7152, 0.0722), layer_color.rgb);
                          break;
                          case 2:
                          //Alpha is Inverted Luminance
                          layer_color.a = dot(vec3(0.2126, 0.7152, 0.0722), vec3(1.0) - layer_color.rgb);
                          break;
                        }


                      // ------------------------------- //
                      //     Radial Fade Texture A       //
                      // --------------------------------//                    
                         
                      // Radial Fade Texture A
                      float radialFaderA = remap(radialFade,0.0,radialFadeA,1.0,0.0,radialFade_SoftnessA);
                      layer_color.a *= radialFaderA;

                      // Square Alpha Generation to cut off repeating elements due to per Map Scale Offset
                       d = abs(((n_uv*MapASize)));
                       d = pow(d,vec2(2000));
                       MixVal = (d.x+d.y);
                       MixVal = 1.0-MixVal;
                       MixVal = float(MixVal>0.5)+MixVal*2.0;
                       MixVal = clamp(MixVal,0.0,1.0);


                      layer_color.a *= MixVal;

                      layer_color.a  = clamp(layer_color.a,0.0,1.0);
                      

                      // layer_color_Comb_C is what is being accessed int the end
                      // I always write into _C in the end no matter how many textures are used
                      layer_color_comb_C = layer_color;

        
                      // --------------------------------------------------------- //
                      //                     Texture B slot in Use                 //
                      // ----------------------------------------------------------//                     
                  
                      if (textureCount > 1.0)
                        {
                          layer_color_B = texture(textureB,n_uv*MapBSize);
                          layer_color_B.rgb = mix(layer_color_B.rgb,vec3(1.0)-layer_color_B.rgb,invert_textureB);


                          // Determine what Alpha is being used. 1) From loaded image 2) Luminance 3)Inv Luminance
                          // Please note the texture invert is being evaluated before !
                          switch (textureB_AlphaMode)
                            {
                              case 0:
                              //From Map
                              break;
                              case 1:
                              //Alpha is Luminance
                              layer_color_B.a = dot(vec4(0.2126, 0.7152, 0.0722, 0.0), layer_color_B);
                              break;
                              case 2:
                              //Alpha is Inverted Luminance
                              layer_color_B.a = dot(vec4(0.2126, 0.7152, 0.0722, 0.0), vec4(1.0) - layer_color_B);
                              break;
                            }

                          // ------------------------------- //
                          //     Radial Fade Texture B       //
                          // --------------------------------//                    
                             
                          // Radial Fade Texture B
                          float radialFaderB = remap(radialFade,0.0,radialFadeB,1.0,0.0,radialFade_SoftnessB);
                          layer_color_B.a *= radialFaderB;
                        

                          // Square Alpha Generation to cut off repeating elements due to per Map Scale Offset
                           d = abs(((n_uv*MapBSize)));
                           d = pow(d,vec2(2000));
                           MixVal = (d.x+d.y);
                           MixVal = 1.0-MixVal;
                           MixVal = float(MixVal>0.5)+MixVal*2.0;
                           MixVal = clamp(MixVal,0.0,1.0);

                          layer_color_B.a *= MixVal;

                          layer_color_B.a = clamp(layer_color_B.a,0.0,1.0);

                          _tmpmix = udnVor(noi * 1234,6.0,0.0,1.0,textureB_weight,0.0);

                          // the following is used to determine the HSV Shift Amount to be mixed into TextureB
                          HSSVFinalMix = mix(HSVMixB,HSVMixA,_tmpmix);

                          layer_color_comb = mix(layer_color_B,layer_color,_tmpmix);
                          layer_color_comb_C = layer_color_comb;
                                 
                        }


                      // --------------------------------------------------------- //
                      //                      Texture C slot  in Use               //
                      // ----------------------------------------------------------//                       
                          
                      if (textureCount > 2.0)
                        {
                          layer_color_C = texture(textureC,n_uv*MapCSize);
                          layer_color_C.rgb = mix(layer_color_C.rgb,vec3(1.0)-layer_color_C.rgb,invert_textureC);

                          // Determine what Alpha is being used. 1) From loaded image 2) Luminance 3)Inv Luminance
                          // Please note the texture invert is being evaluated before !
                          switch (textureC_AlphaMode)
                            {
                              case 0:
                              //From Map
                              break;
                              case 1:
                              //Alpha is Luminance
                              layer_color_C.a = dot(vec4(0.2126, 0.7152, 0.0722, 0.0), layer_color_C);
                              break;
                              case 2:
                              //Alpha is Inverted Luminance
                              layer_color_C.a = dot(vec4(0.2126, 0.7152, 0.0722, 0.0), vec4(1.0) - layer_color_C);
                              break;
                            }

                          // ------------------------------- //
                          //     Radial Fade Texture C       //
                          // --------------------------------//                    
                             
                          // Radial Fade Texture C
                          float radialFaderC = remap(radialFade,0.0,radialFadeC,1.0,0.0,radialFade_SoftnessC);
                          layer_color_C.a *= radialFaderC;


                          // Square Alpha Generation to cut off repeating elements due to per Map Scale Offset
                           d = abs(((n_uv*MapCSize)));
                           d = pow(d,vec2(2000));
                           MixVal = (d.x+d.y);
                           MixVal = 1.0-MixVal;
                           MixVal = float(MixVal>0.5)+MixVal*2.0;
                           MixVal = clamp(MixVal,0.0,1.0);


                          layer_color_C.a *= MixVal;

                          layer_color_C.a = clamp(layer_color_C.a,0.0,1.0);

                          _tmpmix = udnVor(noi * 2345,6.0,0.0,1.0,textureC_weight,0.0);

                          // the following is used to determine the HSV Shift Amount to be mixed into TextureC
                          HSSVFinalMix = mix(HSVMixC,HSSVFinalMix,_tmpmix);

                          layer_color_comb_B = mix(layer_color_C,layer_color_comb,_tmpmix);
                          layer_color_comb_C = layer_color_comb_B;
                        }


                      // --------------------------------------------------------- //
                      //                      Texture D slot in Use                //
                      // ----------------------------------------------------------//                      
                          
                      if (textureCount > 3.0)
                        {
                          layer_color_D = texture(textureD,n_uv*MapDSize);
                          layer_color_D.rgb = mix(layer_color_D.rgb,vec3(1.0)-layer_color_D.rgb,invert_textureD);

                          // Determine what Alpha is being used. 1) From loaded image 2) Luminance 3)Inv Luminance
                          // Please note the texture invert is being evaluated before !
                          switch (textureD_AlphaMode)
                            {
                              case 0:
                              //From Map
                              break;
                              case 1:
                              //Alpha is Luminance
                              layer_color_D.a = dot(vec4(0.2126, 0.7152, 0.0722, 0.0), layer_color_C);
                              break;
                              case 2:
                              //Alpha is Inverted Luminance
                              layer_color_D.a = dot(vec4(0.2126, 0.7152, 0.0722, 0.0), vec4(1.0) - layer_color_D);
                              break;
                            }

                          // ------------------------------- //
                          //     Radial Fade Texture D       //
                          // --------------------------------//                    
                             
                          // Radial Fade Texture D
                          float radialFaderD = remap(radialFade,0.0,radialFadeD,1.0,0.0,radialFade_SoftnessD);
                          layer_color_D.a *= radialFaderD;

                          // Square Alpha Generation to cut off repeating elements due to per Map Scale Offset
                           d = abs(((n_uv*MapDSize)));
                           d = pow(d,vec2(2000));
                           MixVal = (d.x+d.y);
                           MixVal = 1.0-MixVal;
                           MixVal = float(MixVal>0.5)+MixVal*2.0;
                           MixVal = clamp(MixVal,0.0,1.0);


                          layer_color_D.a *= MixVal;
                          layer_color_D.a = clamp(layer_color_D.a,0.0,1.0);

                          _tmpmix = udnVor(noi * 3456,6.0,0.0,1.0,textureD_weight,0.0);


                          // the following is used to determine the HSV Shift Amount to be mixed into TextureC
                          HSSVFinalMix = mix(HSVMixD,HSSVFinalMix,_tmpmix);


                          layer_color_comb_C = mix(layer_color_D,layer_color_comb_B,_tmpmix);
                        }
                  

// ------------------------------------------------------------------------------------------------------
//                     random  HSV Shift
// ------------------------------------------------------------------------------------------------------                      
                        
                        
                        vec4 orig_color_comb_C =layer_color_comb_C;
                        layer_color_comb_C = mriRgb2Hsv(layer_color_comb_C);
                        layer_color_comb_C.r += udnVor(noi * 1234,HSVSeed+(HSVSeed+2.0),A_minH,A_maxH,0.5,1.0);                                       
                        layer_color_comb_C.g *= udnVor(noi * 2345,HSVSeed,A_minS,A_maxS,0.5,1.0);
                        layer_color_comb_C.b *= (udnVor(noi * 3456,HSVSeed-(HSVSeed/4.0),A_minV+ValueOffset,A_maxV+ValueOffset,0.5,1.0)) + ((LayerAttenuation*layer_idx)/layers);                               
                        layer_color_comb_C = mriHsv2Rgb(layer_color_comb_C);
                        layer_color_comb_C = mix(orig_color_comb_C,layer_color_comb_C,HSSVFinalMix);


// ------------------------------------------------------------------------------------------------------
//                     Per Cell Alpha Generation
// ------------------------------------------------------------------------------------------------------                      
                        
  
                        // Square Alpha Generation to cut off repeating elements due to Scale Randomization
                        d = abs(((n_uv)));
                        d = pow(d,vec2(2000));
                        MixVal = (d.x+d.y);
                        MixVal = 1.0-MixVal;
                        MixVal = float(MixVal>0.5)+MixVal*2.0;
                        MixVal = clamp(MixVal,0.0,1.0);

                        // Applying Alpha Cutoff for Scale Randomization
                        layer_alpha = layer_color_comb_C.a * MixVal;

                        //writing this into vec4 because Comp_Default needs it
                        layer_opac = vec4(layer_alpha);
            
       					        // Creating Alpha based on surface (alpha=0)
                        // There are some pre-mult issues here when blending layer_opac
                        // (the vec4 version of layer_alpha) with layer_alpha
                        surface_opac = Comp_Screen(surface_opac,layer_opac,1.0);
          
          

// ------------------------------------------------------------------------------------------------------
//                      Blend Modes for each Cell
// ------------------------------------------------------------------------------------------------------                      
                        
                        // Combine according to Blend Mode:
                        switch (BlendMode)
                          {
                            case 0:
                            // OVER
                            surface_color = Comp_Default(surface_color,layer_color_comb_C,layer_alpha);
                            break;
                            case 1:
                            //ADD
                            surface_color = Comp_Add(surface_color,layer_color_comb_C,layer_alpha);
                            break;
                            case 2:
                            // SCREEN
                            surface_color = Comp_Screen(surface_color,layer_color_comb_C,layer_alpha);
                            break;
                            case 3:
                            // MULTIPLY
                            surface_color = Comp_Multiply(surface_color,layer_color_comb_C,layer_alpha);
                            break;
                            case 4:
                            // SOFT LIGHT
                             surface_color = Comp_SoftLight(surface_color,layer_color_comb_C,layer_alpha);
                            break;
                            case 5:
                            // HARD LIGHT
                             surface_color = Comp_HardLight(surface_color,layer_color_comb_C,layer_alpha);
                            break;
                            case 6:
                            // HARD MIX
                             surface_color = Comp_HardMix(surface_color,layer_color_comb_C,layer_alpha);
                            break;
                            case 7:
                            // OVERLAY
                             surface_color = Comp_Overlay(surface_color,layer_color_comb_C,layer_alpha);
                            break;
                          }



                    }
                				
       	    }		
        }
      }
  }


// ------------------------------------------------------------------------------------------------------
//                      OUTPUT
// ------------------------------------------------------------------------------------------------------                      
                        

        vec4 output = mix(surface_color,clamp(surface_color,vec4(0.0),vec4(1.0)),clampValues);
        // float test = steppedFBM(rel_s,1.0,0.0,1.0,0.0,1.0);
         // output = vec4(_floatPreview*2.0,_floatPreview,_floatPreview,1.0);
        return output;

}


