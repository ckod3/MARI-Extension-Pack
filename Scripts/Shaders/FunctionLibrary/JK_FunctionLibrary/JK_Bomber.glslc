#version 330

// ------------------------------------------------------------------------
// INCLUDES
// ------------------------------------------------------------------------

//! include | Noise.glslh

// ------------------------------------------------------------------------
// Forward declaration from other files
// ------------------------------------------------------------------------

vec4 Comp_Default(vec4 Base, vec3 Blend, float Amount);
vec4 Comp_Default(vec4 base, vec4 blend, float Opacity);
vec4 Comp_Add(vec4 Base, vec3 Blend, float Amount);
vec4 Comp_Add(vec4 Base, vec4 Blend, float Amount);
float noise1D(float p);
float Value3D( vec3 P );
void voronoi(vec3 position, float jitterD, int distype, out float f1, out float f2, out vec3 pos1,
         out vec3 pos2, out vec3 f1cell, out vec3 f2cell);


// ------------------------------------------------------------------------
// MACROS
// ------------------------------------------------------------------------
//         
//uniform distributed noise, tiling, rotation and blending 

// TO DO:
// create bettern 1d noise function for udn macro


#define whichtile(x,freq) (floor((x) * (freq)))
#define rotate2d(x,y,rad,ox,oy,rx,ry) \
				{\	rx = ((x) - (ox)) * cos(rad) - ((y) - (oy)) * sin(rad) + (ox);\
				 ry = ((x) - (ox)) * sin(rad) + ((y) - (oy)) * cos(rad) + (oy);\
				}
        								

#define blend(a,b,x) ((a) * (1 - (x)) + (b) * (x))



// ------------------------------------------------------------------------
// FUNCTIONS
// ------------------------------------------------------------------------

float udn(float x,float scale,float lo,float hi)
{ 

  vec3 x_3 = vec3(x);
  float valnoi = Value3D(x_3);
  float output = (smoothstep(.25, .75, (valnoi)) * ((hi) - (lo)) + (lo));
  return output;

}

float udnVor(float x,float scale,float lo,float hi)
{ 

  vec3 x_3 = vec3(x*scale);
  float outf1,outf2;
  vec3 pos1,pos2,f1cell,f2cell;

  //initalize voronoi
  voronoi(x_3,1.0,1, outf1, outf2,pos1,pos2, f1cell, f2cell);

  float remap = f1cell.r;

  float output = (smoothstep(.25, .75, (remap)) * ((hi) - (lo)) + (lo));
  return output;

}



vec4 bomb_testB( 
					vec2 UV,
					vec3 POS,
					float scale,
					float frequency,
					float layers,
					float noise_scale,
          float jitter_scale,
					float rot_min,
					float rot_max,
          float tmp,
					sampler2D textureA,
					sampler2D alphaA
				)



{

	// unassigned variables

	vec4 layer_color,surface_color;
	vec4 layer_opac,surface_opac;
	float surface_opac_a;
	float ss, tt,tmps,tmpt;
	float home_row,home_col;
	float layer_idx,col_idx,row_idx;
	float cell_size;
	float half_cell;
	float col, row;
  float noi;
  float swidth, twidth;
  vec3 Nf, V;
  float ds,dsu,dsv,dt,dtu,dtv;
  float rel_s, rel_t;
  float jitter_s, jitter_t;
  float center_s, center_t;
  float sMin, sMax, tMin, tMax;
  float inBounds;
  float max_jitter;
  float offset;

  cell_size = 1.0 / scale;
  half_cell = cell_size / 2.0;

  // assigned variables

  surface_color = vec4(0.0,0.0,0.0,0.0);
  surface_opac = vec4(0.0,0.0,0.0,1.0);

	float s = UV.x;
	float t = UV.y;




    home_col = whichtile(s,scale);
    home_row = whichtile(t,scale);



       	for (layer_idx = 0.999; layer_idx < layers; layer_idx += 1.0)
       	{
       		// /* scan current cell and neighbors, 9 cells total */
       		for (col_idx = -1.0; col_idx <= 1.0; col_idx += 1.0)
       		{
       			for (row_idx = -1.0; row_idx <= 1.0; row_idx += 1.0)
       			{
       				/* determine row and column index, wraparound */
       				rel_s = s;
       				rel_t = t;
					
					col = home_col + col_idx;
       				
       					if (col < 0.0) 
       					{
       						rel_s = s + 1.0;
       						col = scale - 1.0;
       					}
       					
       					if (col >= scale) 
       					{
       						rel_s = s - 1.0;
       						col = 0.0;
       					}
       				
       					row = home_row + row_idx;

       					if (row < 0.0) 
       					{
       						rel_t = t + 1.0;
       						row = scale - 1.0;
       					}

       					if (row >= scale) 

       					{
       						rel_t = t - 1.0;
       						row = 0.0;
       					}



                 // ADD A VALUE HERE TO SEED:

              		/* base seed to udn on current layer, row and column of tile */	
		       		noi = (Value3D(vec3 (col * noise_scale + 0.5, row * noise_scale + 0.5, 
       						layer_idx * noise_scale + 0.5))) ;





					// noi = mriSimplexNoise(POS*vec3(noise_scale));

					// noi = 1.0;


       	

		       		//generate tile based on noise < frequency
       					if ((noi * 313) < frequency) 
       					{			
       						// calculate jitter --- 0.25
       						max_jitter = cell_size*0.5;
       						jitter_s = udnVor(noi * 1183,jitter_scale, -max_jitter, max_jitter);
       						jitter_t = udnVor(noi * 999,jitter_scale, -max_jitter, max_jitter) ;
       		
       						
       						// calculate center of texture on surface
       						center_s = ((col * cell_size) + half_cell + jitter_s);
       						center_t = ((row * cell_size) + half_cell + jitter_t);

       	


                  // Rotation
     							float x = udn(rel_s,1.0,rel_s,0.0);
     							float y = udn(rel_t,1.0,rel_t,0.0);
     							float rad = radians(udnVor(noi * 777,noise_scale/2.0, rot_min, rot_max));
     							float ox = (col * cell_size) + half_cell;
							   	float oy = (row * cell_size) + half_cell;


     							tmps = ((x) - (ox)) * cos(rad) - ((y) - (oy)) * sin(rad) + (ox);
     							tmpt = ((x) - (ox)) * sin(rad) + ((y) - (oy)) * cos(rad) + (oy);







       		
       						// calculate boundaries for texture in this layer
       						sMin = center_s - half_cell;
       						sMax = center_s + half_cell;
       						tMin = center_t - half_cell;
       						tMax = center_t + half_cell;
       					
       						// determine if the current point on the surface is in the texture area
       						inBounds = 1.0;
       						if (tmps <= sMin) inBounds = 0;
       						if (tmps >= sMax) inBounds = 0;
       						if (tmpt <= tMin) inBounds = 0;
       						if (tmpt >= tMax) inBounds = 0;
       			
       							if (inBounds == 1.0)
       							{
       			
       							// calculate texture coordinates
       								ss = (tmps - sMax) * scale;
       								// ss = (rel_s - sMin) * scale;

       								tt = (tmpt - tMax) * scale;
       								// tt = (rel_t - tMin) * scale;

       								vec2 n_uv = vec2(ss,tt);


                      /* get color from texture map*/
                      layer_color = texture(textureA,n_uv);
                      layer_color = vec4(
                                             layer_color.r - udnVor(noi * 1234,6.0,0.0,0.4),
                                             layer_color.g - udnVor(noi * 2345,6.0,0.0,0.4),
                                             layer_color.b - udnVor(noi * 3456,6.0,0.0,0.4),
                                             layer_color.a

                        )  ;      



                      // layer_color.a = (1.0-(mixval_1 * mixval_2)) * layer_color.a;



       								/* get opacity from texture map*/
       								layer_opac = vec4(layer_color.a);

       								// surface_opac = Comp_Add(surface_opac,layer_opac,1.0);
       								surface_opac = Comp_Default(surface_opac,layer_opac,layer_color.a);

       								surface_opac_a = clamp(surface_opac.r,1.0,0.0);


       								surface_color = Comp_Default(surface_color,layer_color,layer_color.a);



       							}		
       				}		
       			}
       		}
       	}


       						vec4 output = vec4(surface_color);
							// vec4 output = vec4(n_uv,n_uv);
							// vec4 output = vec4(n_uv.r,n_uv.g,0.0,1.0);
       						
       						return output;


}


