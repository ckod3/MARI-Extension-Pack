#version 330

// ------------------------------------------------------------------------
// INCLUDES
// ------------------------------------------------------------------------

//! include | Noise.glslh
//! include | Comp.glslh

// ------------------------------------------------------------------------
// Forward declaration from other files
// ------------------------------------------------------------------------


float Value3D( vec3 P );
void voronoi(vec3 position, float jitterD, int distype, out float f1, out float f2, out vec3 pos1,
         out vec3 pos2, out vec3 f1cell, out vec3 f2cell);
vec4 CellNoise( vec3 gridcell );
float SimplexPerlin3D(vec3 P);

// for use in voronoi_simple
float rnd_1d(vec2 x);
float dist_Squared(float x, float y, float z);
float softThreshold(float threshold, float bound, float value);

// ------------------------------------------------------------------------
// TO DO
// ------------------------------------------------------------------------
//   


// TO DO:
//
// TEST CONVERT TO PAINTABLE !!!!
// -- Add Inverse Multiply
// -- Add Stencil/Alpha is Luminance etc.
// ++ create bettern 1d noise function for udn macro
// ++ create simpler, faster to run Voronoi
// ++ add multiple texture support
// - add varying cell size
// - add 3d projection of cells
// ++ add HSV/A Min/Max. Color seeding looks useless.
// - add optional clamping at the end due to HSV Adding
// - investigate faint grid lines in texture ? Fract/floor'ing ? 
// ++ add per texture importance
// - add blend modes
//
//   AS ADJUSTMENT LAYER/USING INCOMING DATA: 
// - add painted distribution of cells. Sampling from incoming texture layers, then only using
//   transparency from bomber
// - potentially add distribution per texture via RGB Values of incoming vec4 data
// - potentially add switch to paint frequency/denisity per texture via RGB (similar to above)




// ------------------------------------------------------------------------
// MACROS
// ------------------------------------------------------------------------


#define whichtile(x,freq) (floor((x) * (freq)))



// ------------------------------------------------------------------------
// FUNCTIONS
// ------------------------------------------------------------------------


// voronoi cellular pattern generator from DT3D_CellularNoise.glslc but simplified for better performance
void voronoi_simple(vec3 position, float jitterD,out vec3 f1cell,float threshold,float threshold_bound)
{
    vec3 thiscell = floor(position)+0.5f;
    float i, j, k, dist;

    vec3 c;
    for(i = -1; i <= 1; i += 1)
    {
        for(j = -1; j <= 1; j += 1)
        {
            for(k = -1; k <= 1; k += 1)
            {
                vec3 testcell = thiscell  + vec3(i,j,k);
                vec3 randomUVW = testcell * vec3(0.037f, 0.119f, .093f);
                float cellnoise = (rnd_1d(randomUVW.xy+randomUVW.z+0.2),rnd_1d(randomUVW.xy+randomUVW.z+0.5),rnd_1d(randomUVW.xy+randomUVW.z+0.3));
                vec3 pos = testcell + jitterD*(cellnoise-0.5);
                vec3 offset = pos - position;
                dist = dist_Squared(offset.x,offset.y,offset.z);
   
                f1cell = vec3( softThreshold(threshold,threshold_bound,cellnoise) );      

            
            }
        }
    }
}



float udn(float x,float scale,float lo,float hi)
{ 

  vec3 x_3 = vec3(x*scale);
  float valnoi = Value3D(x_3);
  float output = (smoothstep(.25, .75, (valnoi)) * ((hi) - (lo)) + (lo));
  return output;

}



float udnVor(float x,float scale,float lo,float hi, float threshold, float threshold_bound)
{ 

  vec3 x_3 = vec3(x*scale);
  float outf1,outf2;
  vec3 pos1,pos2,f1cell,f2cell;

  voronoi_simple(x_3,1.0,f1cell,threshold,threshold_bound);

  float remap = f1cell.r;

  float output = (smoothstep(.25, .75, (remap)) * ((hi) - (lo)) + (lo));
  return output;


}



vec4 JK_texScatter( 

                vec2 UV,
                vec3 POS,
                float scale,
                float frequency,
                float layers,
                float noise_scale,
                float jitter_scale,
                float rot_min,
                float rot_max,
                int textureCount,
                int BlendMode,
                float HSVSeed,
                float A_minH,
                float A_maxH,
                float A_minS,
                float A_maxS,
                float A_minV,
                float A_maxV,
                float clampValues,
                sampler2D textureA,
                float invert_textureA,
                int textureA_AlphaMode,
                sampler2D textureB,
                float textureB_weight,
                float invert_textureB,
                int textureB_AlphaMode,
                sampler2D textureC,
                float textureC_weight,
                float invert_textureC,
                int textureC_AlphaMode,
                sampler2D textureD,
                float textureD_weight,
                float invert_textureD,
                int textureD_AlphaMode
				)



{

	// unassigned variables

	vec4 layer_color,layer_color_B,layer_color_C,layer_color_D;
  vec4 surface_color;
  vec4 layer_color_comb,layer_color_comb_B,layer_color_comb_C;
	vec4 layer_opac,surface_opac;
  float rnd;
  float layer_alpha;
	float surface_opac_a;
	float ss, tt, ss_b,tt_b,tmps,tmpt;
	float home_row,home_col;
	float layer_idx,col_idx,row_idx;
	float cell_size;
	float half_cell;
	float col, row;
  float noi;
  float swidth, twidth;
  vec3 Nf, V;
  float ds,dsu,dsv,dt,dtu,dtv;
  float rel_s, rel_t;
  float jitter_s, jitter_t;
  float center_s, center_t;
  float sMin, sMax, tMin, tMax;
  float inBounds;
  float max_jitter;
  float offset;
  float base_freq;


  cell_size = 1.0 / scale;
  half_cell = cell_size / 2.0;



  // assigned variables

  surface_color = vec4(0.0,0.0,0.0,0.0);
  surface_opac = vec4(0.0,0.0,0.0,1.0);
  float texCount = float(textureCount);
	float s = UV.x;
	float t = UV.y;

  home_col = whichtile(s,scale);
  home_row = whichtile(t,scale);


      // small offset on layer idx to compensate for precision
       	for (layer_idx = 0.999; layer_idx < layers; layer_idx += 1.0)
       	{
       		// scan current cell and neighbors, 9 cells total
       		for (col_idx = -1.0; col_idx <= 1.0; col_idx += 1.0)
       		{
       			for (row_idx = -1.0; row_idx <= 1.0; row_idx += 1.0)
       			{
       				// determine row and column index, wraparound
       				rel_s = s;
       				rel_t = t;
					
					    col = home_col + col_idx;
       				
       					if (col < 0.0) 
       					{
       						rel_s = s + 1.0;
       						col = scale - 1.0;
       					}
       					
       					if (col >= scale) 
       					{
       						rel_s = s - 1.0;
       						col = 0.0;
       					}
       				
       					row = home_row + row_idx;

       					if (row < 0.0) 
       					{
       						rel_t = t + 1.0;
       						row = scale - 1.0;
       					}

       					if (row >= scale) 

       					{
       						rel_t = t - 1.0;
       						row = 0.0;
       					}


              		// base seed on current layer, row and column of tile	
		       		    noi = (Value3D ( vec3(col * noise_scale + 0.5, 
                                       row * noise_scale + 0.5,
                                       layer_idx * noise_scale + 0.5)
                                 ) + 1.0
                        ) ;
       	

		       		  //generate tile

       				       if ((noi * 626) < frequency) 
       				       {			
       				       	//jitter
       				       	max_jitter = cell_size*0.5;
       				       	jitter_s = udnVor(noi * 1183,jitter_scale, -max_jitter, max_jitter,0.5,1.0);
       				       	jitter_t = udnVor(noi * 999,jitter_scale, -max_jitter, max_jitter,0.5,1.0) ;
       		
       				       	
       				       	//center of texture on surface
       				       	center_s = ((col * cell_size) + half_cell + jitter_s);
       				       	center_t = ((row * cell_size) + half_cell + jitter_t);

       	


                        // Rotation
     					        	float x = udn(rel_s,1.0,rel_s,0.0);
     					        	float y = udn(rel_t,1.0,rel_t,0.0);
     					        	float rad = radians(udnVor(noi * 777,noise_scale/2.0, rot_min, rot_max,0.5,1.0));
     					        	float ox = (col * cell_size) + half_cell;
							        	float oy = (row * cell_size) + half_cell;
     					        	tmps = ((x) - (ox)) * cos(rad) - ((y) - (oy)) * sin(rad) + (ox);
     					        	tmpt = ((x) - (ox)) * sin(rad) + ((y) - (oy)) * cos(rad) + (oy);


       					      	//bounds for texture in this layer
       					      	sMin = center_s - half_cell;
       					      	sMax = center_s + half_cell;
       					      	tMin = center_t - half_cell;
       					      	tMax = center_t + half_cell;
       					      
       					      	// check if the current point on the surface is in the texture area
       					      	inBounds = 1.0;
       					      	if (tmps <= sMin) inBounds = 0;
       					      	if (tmps >= sMax) inBounds = 0;
       					      	if (tmpt <= tMin) inBounds = 0;
       					      	if (tmpt >= tMax) inBounds = 0;
       			      
       						     	if (inBounds == 1.0)
       						     	{
       			      
       						     	// calculate texture coordinates
       						     		ss = (tmps - sMax) * scale;
       						     		tt = (tmpt - tMax) * scale;
                          
       						     		vec2 n_uv = vec2(ss,tt);
                          vec2 n_uv_B = vec2(ss_b,tt_b);
      
    
                          // get color from texture maps and weigh them per importance
                          // importance is determined via thresholding function
                          // Depending on Mode set, Alphas are evaluated differently via Switches
                           layer_color = texture(textureA,n_uv);
                           layer_color.rgb = mix(layer_color.rgb,vec3(1.0)-layer_color.rgb,invert_textureA);

                                    switch (textureA_AlphaMode)
                                        {
                                           case 0:
                                           //From Map
                                           break;
                                           case 1:
                                           //Alpha is Luminance
                                           layer_color.a = dot(vec3(0.2126, 0.7152, 0.0722), layer_color.rgb);
                                           break;
                                           case 2:
                                           //Alpha is Inverted Luminance
                                           layer_color.a = dot(vec3(0.2126, 0.7152, 0.0722), vec3(1.0) - layer_color.rgb);
                                           break;

                                         }


                           layer_color_comb_C = layer_color;
        
                                 if (textureCount > 1.0)
                                 { layer_color_B = texture(textureB,n_uv);

                                          switch (textureB_AlphaMode)
                                        {
                                           case 0:
                                           //From Map
                                           break;
                                           case 1:
                                           //Alpha is Luminance
                                           layer_color_B.a = dot(vec4(0.2126, 0.7152, 0.0722, 0.0), layer_color_B);
                                           break;
                                           case 2:
                                           //Alpha is Inverted Luminance
                                           layer_color_B.a = dot(vec4(0.2126, 0.7152, 0.0722, 0.0), vec4(1.0) - layer_color_B);
                                           break;
                                         }

                                   layer_color_comb = mix(layer_color_B,layer_color,udnVor(noi * 1234,6.0,0.0,1.0,textureB_weight,0.0));
                                   layer_color_comb_C = layer_color_comb;
                                 }
            
                                 if (textureCount > 2.0)
                                 { layer_color_C = texture(textureC,n_uv); 

                                          switch (textureC_AlphaMode)
                                        {
                                           case 0:
                                           //From Map
                                           break;
                                           case 1:
                                           //Alpha is Luminance
                                           layer_color_C.a = dot(vec4(0.2126, 0.7152, 0.0722, 0.0), layer_color_C);
                                           break;
                                           case 2:
                                           //Alpha is Inverted Luminance
                                           layer_color_C.a = dot(vec4(0.2126, 0.7152, 0.0722, 0.0), vec4(1.0) - layer_color_C);
                                           break;
                                         }


                                   layer_color_comb_B = mix(layer_color_C,layer_color_comb,udnVor(noi * 2345,6.0,0.0,1.0,textureC_weight,0.0));
                                   layer_color_comb_C = layer_color_comb_B;
                                 }
            
                                 if (textureCount > 3.0)
                                 { layer_color_D = texture(textureD,n_uv);

                                          switch (textureD_AlphaMode)
                                        {
                                           case 0:
                                           //From Map
                                           break;
                                           case 1:
                                           //Alpha is Luminance
                                           layer_color_D.a = dot(vec4(0.2126, 0.7152, 0.0722, 0.0), layer_color_C);
                                           break;
                                           case 2:
                                           //Alpha is Inverted Luminance
                                           layer_color_D.a = dot(vec4(0.2126, 0.7152, 0.0722, 0.0), vec4(1.0) - layer_color_D);
                                           break;
                                         }

                                   layer_color_comb_C = mix(layer_color_D,layer_color_comb_B,udnVor(noi * 3456,6.0,0.0,1.0,textureD_weight,0.0));
                                 }
                      
                           layer_color_comb_C = mriRgb2Hsv(layer_color_comb_C);


                             // per cell hsv shift
                             // R = H, G = S, B = V, A = A
                             layer_color_comb_C.r += udnVor(noi * 1234,HSVSeed+(HSVSeed/2.0),A_minH,A_maxH,0.5,1.0);                                       
                             layer_color_comb_C.g *= udnVor(noi * 2345,HSVSeed,A_minS,A_maxS,0.5,1.0);
                             layer_color_comb_C.b *= udnVor(noi * 3456,HSVSeed-(HSVSeed/4.0),A_minV,A_maxV,0.5,1.0);                               
                             layer_color_comb_C = mriHsv2Rgb(layer_color_comb_C);

                             


// ----------------- CHECK IF THE SURFACE OPACITY IS NEEDED OR JUST A WASTE OF SPACE !!!!!!!!!!!

       								         /* get opacity from texture map*/
                                layer_alpha = layer_color_comb_C.a;
       								         layer_opac = vec4(layer_alpha);
          
       								         // surface_opac = Comp_Add(surface_opac,layer_opac,1.0);
       								         surface_opac = Comp_Default(surface_opac,layer_opac,layer_alpha);
          
       								         // surface_opac_a = clamp(surface_opac.r,1.0,0.0);
          
                              // Combine according to Blend Mode:
                              switch (BlendMode)
                               {

                                   case 0:
                                   // OVER
                                   surface_color = Comp_Default(surface_color,layer_color_comb_C,layer_alpha);
                                   break;
                                   case 1:
                                   //ADD
                                   surface_color = Comp_Add(surface_color,layer_color_comb_C,layer_alpha);
                                   break;
                                   case 2:
                                   // SCREEN
                                   surface_color = Comp_Screen(surface_color,layer_color_comb_C,layer_alpha);
                                   break;
                                   case 3:
                                   // MULTIPLY
                                   surface_color = Comp_Multiply(surface_color,layer_color_comb_C,layer_alpha);
                                   break;
                                   case 4:
                                   // SOFT LIGHT
                                    surface_color = Comp_SoftLight(surface_color,layer_color_comb_C,layer_alpha);
                                   break;
                                   case 5:
                                   // HARD LIGHT
                                    surface_color = Comp_HardLight(surface_color,layer_color_comb_C,layer_alpha);
                                   break;
                                   case 6:
                                   // HARD MIX
                                    surface_color = Comp_HardMix(surface_color,layer_color_comb_C,layer_alpha);
                                   break;
                                   case 7:
                                   // OVERLAY
                                    surface_color = Comp_Overlay(surface_color,layer_color_comb_C,layer_alpha);
                                   break;



                               }



       					    }
                				
       				}		
       			}
       		}
       	}


       						vec4 output = mix(surface_color,clamp(surface_color,vec4(0.0),vec4(1.0)),clampValues);
                  // vec4 output = vec4(udn(1234,scale,0.0,0.5));
                  // output.a = 1.0;
							   // vec4 output = vec4(n_uv,n_uv);
							   // vec4 output = vec4(n_uv.r,n_uv.g,0.0,1.0);
       						// float test = udn(rel_s,POS,1.0,rel_s,0.0);
                  // output = vec4(test,test,test,1.0);
       						return output;


}


